/*
 *    Copyright Â© 2001 Red Hat, Inc.
 *
 *    This file is part of wdaemon.
 *
 *    wdaemon is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    wdaemon is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with wademon; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <evemu.h>

#include "session.h"
#include "monitored.h"
#include "uinput.h"
#include "hotplug.h"
#include "wdaemon-evemu.h"

/**
 * Extract the device description for the device at the given path into the
 * output file. This file can later be used to re-load a description of the
 * device.
 *
 * @return 0 on success or 1 otherwise.
 */
int evemu_extract_device(struct session *session, const char *path, const char *output_file)
{
	int rc = 1;
	int in = 0; /* input device */
	FILE *out;
	struct evemu_device *dev = NULL;

	in = open(path, O_RDWR);
	if (in == -1) {
		fprintf(stderr, "Failed to open path '%s': %s\n",
			path, strerror(errno));
		goto out;
	}

	out = fopen(output_file, "w");
	if (!out) {
		fprintf(stderr, "Failed to open path '%s': %s\n",
			output_file, strerror(errno));
		goto out;
	}

	dev = evemu_new(NULL);
	if (!dev) {
		fprintf(stderr, "Failed to create evemu device.\n");
		goto out;
	}

	rc = evemu_extract(dev, in);
	if (rc) {
		fprintf(stderr, "Data extraction failed.\n");
		goto out;
	}

	evemu_write(dev, out);
	rc = 0;

out:
	if (in != -1)
		close(in);
	if (out)
		fclose(out);
	if (dev)
		evemu_delete(dev);

	return rc;
}


static int
evemu_set_initial_values(struct uinput_info *info,
			 struct uinput_user_dev *udev)
{
	int rc = 1;
	struct evemu_device *dev = info->priv;

	rc = evemu_create(dev, info->fd);
	if (rc) {
		fprintf(stderr, "Failed to create evemu device.\n");
		goto out;
	}

	rc = 0;
out:
	return rc;
}

int evemu_enable_events(struct uinput_info *info,
                        struct uinput_user_dev *dev)
{
	/* already done in evemu_set_initial_values */
	return 0;
}


static void
evemu_init(struct uinput_info *info)
{
	info->init_info = evemu_set_initial_values;
	info->enable_events = evemu_enable_events;
	/* we use evemu_create to create the device file */
	info->create_mode = SELF_CREATE;
}

/**
 * Load a device description from the given input file.
 * This file must be generated by wdaemon.
 *
 * @param input_file The evemu device description file.
 * @param path The fixed path to the device (i.e. udev symlink)
 * @return 0 on success or 1 otherwise.
 */
int evemu_load_device(struct session *session,
		      const char *input_file,
		      char *path)
{
	int rc = 1;
	FILE *in = NULL;
	struct evemu_device *dev = NULL;
	char name[UINPUT_MAX_NAME_SIZE];

	in = fopen(input_file, "r");
	if (!in) {
		fprintf(stderr, "Failed to open path '%s': %s\n",
			input_file, strerror(errno));
		goto out;
	}

	dev = evemu_new(NULL);
	if (!dev) {
		fprintf(stderr, "Failed to create evemu device.\n");
		goto out;
	}

	if (evemu_read(dev, in) <= 0) {
		fprintf(stderr, "Failed to read device data.\n");
		goto out;
	}

	memset(name, 0, sizeof(name));
	snprintf(name, sizeof(name), "%s%s%s",
		 WDAEMON_DEVNAME_PREFIX,
		 (strlen(WDAEMON_DEVNAME_PREFIX) > 0) ? ": " : "",
		 evemu_get_name(dev));
	name[sizeof(name) - 1] = '\0'; /* if truncation */

	evemu_set_name(dev, name);
	evemu_set_id_bustype(dev, BUS_VIRTUAL);

	rc = hotplug_add_file(session, path);
	if (rc)
		goto out;
out:
	if (in)
		fclose(in);

	return !rc ? monitored_device_add(session->devices, evemu_init, dev, path) : rc;
}

int add_device_desc(struct session *session, char *path, char *desc)
{
	return evemu_load_device(session, desc, path);
}

/* vim: set noexpandtab tabstop=8 shiftwidth=8: */
